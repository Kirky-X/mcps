### **产品需求文档 (PRD): MCP驱动的自主软件开发代理 (MCP-DevAgent)**

**版本:** 1.0
**状态:** 草案

---

### **1. 产品概述与愿景**

#### **1.1 产品简介**
MCP-DevAgent是一个基于模型上下文协议（MCP）构建的、由大型语言模型（LLM）驱动的自主软件开发代理。它的核心目标是模拟一个具备专业素养、遵循严格软件工程最佳实践的软件工程师，能够自主完成从需求理解、规划、编码、测试到修复的完整开发周期。

#### **1.2 解决的问题**
当前，直接使用大型语言模型进行代码生成存在诸多问题：
*   **缺乏可控性:** LLM可能会“幻觉”出未定义的功能，或使用项目禁止的技术栈。
*   **缺乏一致性:** 无法保证多次输出的质量和风格一致，难以融入现有代码库。
*   **缺乏深度思考:** 遇到问题时容易陷入重复的错误尝试，无法进行根本原因分析和策略调整。
*   **缺乏沟通:** 整个过程是一个“黑盒”，人类开发者无法理解其决策过程，也无法在关键节点进行干预。

#### **1.3 产品愿景**
我们的愿景是将LLM从一个不可靠的“代码片段生成器”转变为一个值得信赖、高度自主、且流程透明的**AI开发伙伴**。MCP-DevAgent旨在通过一个内置了专业工程纪律和协作协议的框架，来约束和引导LLM的强大能力，从而稳定、高效地交付高质量、可维护的软件。

#### **1.4 目标用户**
*   **软件工程师:** 希望将定义明确的功能模块或修复任务委托给AI，以专注于更复杂的架构设计和创造性工作。
*   **技术团队:** 寻求自动化重复性编码任务、统一团队编码规范、并加速整体开发迭代速度的团队。

---

### **2. 产品目标与成功指标**

*   **目标1: 提升代码产出的准确性和合规性。**
    *   **成功指标:** AI生成的代码100%遵循预定义的技术栈和架构约束；由AI实现的功能与PRD需求的偏差率低于5%。
*   **目标2: 保证开发过程的高度透明与可追溯性。**
    *   **成功指标:** 每一个开发任务都生成一个完整的、结构化的思维链日志；任何代码的演变历史（包括失败的尝试）都可以通过数据库查询进行复现。
*   **目标3: 实现高效的自动化问题解决能力。**
    *   **成功指标:** 80%的单元测试失败能够通过不超过3次的自动修复循环得到解决；系统能够自动识别并上报需要人类决策的复杂问题。
*   **目标4: 优化成本效益。**
    *   **成功指标:** 系统能够将至少50%的简单、结构化任务（如代码格式化、简单修复）路由到成本更低的本地LLM模型执行。

---

### **3. 核心功能与特性**

#### **3.1 结构化的思维链与可追溯的记忆**
*   **特性描述:** 系统将整个开发过程中的每一步思考、决策、代码生成和验证结果都记录在一个SQLite数据库中。这创建了一个可查询、可分析的“思维图谱”。
*   **数据库模式:**
    *   **`development_runs`表:** 记录每个独立的开发任务。
    *   **`thought_steps`表:** 记录每个原子操作（如规划、生成测试、修复代码），包含父子关系、节点类型（线性、修正、分支）、LLM的思考文本和执行状态。
    *   **`code_artifacts`表:** 存储每个步骤生成的代码产物，并进行版本控制。
*   **用户价值:** 提供极致的可解释性，允许开发者精确复盘AI的每一个决策，便于调试和优化。

#### **3.2 严格的开发工作流与执行框架 (LangGraph驱动)**
*   **特性描述:** 整个开发过程由一个基于LangGraph的状态机严格编排，确保所有步骤都按预设的最佳实践执行。
*   **核心流程:**
    1.  **规划与分解:** AI接收PRD，生成一份包含3-5个阶段的`IMPLEMENTATION_PLAN.md`文件，明确每个阶段的目标、成功标准和测试。
    2.  **测试驱动开发 (TDD):** 严格遵循“红-绿-重构”循环。AI首先编写一个失败的测试用例，然后编写最少的代码使其通过，最后进行代码优化。
    3.  **质量门禁:** 每个代码提交前，必须自动通过编译、所有测试、代码格式化和静态代码分析检查。

#### **3.3 深度对齐的人机协作协议**
*   **特性描述:** MCP-DevAgent内置了一套明确的沟通协议，以消除歧义并确保人机之间的持续对齐。
*   **协议细节:**
    *   **意图确认:** 在执行任何复杂任务前，AI必须首先重述其对需求的理解，提供一个简短的输出示例，并明确请求人类确认后方可继续。
    *   **主动进度汇报:** 在完成`IMPLEMENTATION_PLAN.md`中的每一个阶段后，AI会主动报告完成情况，并请求下一步指示。

#### **3.4 智能的问题解决与反思框架**
*   **特性描述:** 当遇到难题时，系统具备自我反思和请求人类协助的能力。
*   **“三振出局”升级机制:**
    1.  对于同一个问题，AI最多尝试自动修复3次。
    2.  如果3次后仍未解决，系统将自动暂停。
    3.  AI会整理一份报告，包含：所有失败尝试的记录、遇到的具体错误、对失败原因的分析、以及通过网络或代码库研究的2-3个备选解决方案。
    4.  最后，AI将这份报告呈现给人类开发者，请求进行决策。

#### **3.5 对现有代码库的深度理解 (RAG)**
*   **特性描述:** 系统具备理解和导航现有复杂代码库的能力，确保新代码与项目既有模式和约定保持一致。
*   **实现原理:** 采用类似SerenaMCP的原理，在任务开始时，通过抽象语法树（AST）和符号依赖分析来索引整个代码库，构建一个代码知识图谱。在代码生成时，通过检索增强生成（RAG）技术，将相关的现有代码片段、API定义和设计模式作为上下文注入到LLM的提示中。

#### **3.6 混合LLM策略与认知路由**
*   **特性描述:** 为了平衡性能与成本，系统采用了一个智能的“认知路由器”来调度不同的LLM。
*   **路由逻辑:**
    *   **简单/结构化任务** (如代码格式化、解析错误日志、简单的语法修复) 将被路由到本地部署的、成本较低的模型（如Ollama托管的模型）。
    *   **复杂/创造性任务** (如初始架构规划、设计复杂算法、深度反思) 将被路由到性能最强的外部模型（如GPT-4、Claude 3 Opus等）。

#### **3.7 需求分析与澄清能力**
*   **特性描述:** 在规划阶段之前，系统具备一个独立的“需求分析代理”，负责审查初始PRD的清晰度和完整性。
*   **工作流程:** 该代理会分析需求文档，识别出其中可能存在的歧义、遗漏或冲突，并生成一个问题列表，主动向人类开发者提问以寻求澄清。

#### **3.8 代码重构能力**
*   **特性描述:** 在TDD循环的“重构”阶段，或在开发完成后，系统可以被指示对生成的代码进行优化。
*   **功能:** 识别并修复代码中的“坏味道”，如过长的函数、重复代码、不合理的命名等，同时确保所有现有测试仍然通过。

---

### **4. 系统架构与技术要求**

*   **流程编排引擎:** LangGraph，用于构建和管理复杂、有条件、循环的开发工作流。
*   **记忆与状态存储:** SQLite数据库，用于持久化存储思维链和代码产物。
*   **代码理解引擎:** 基于AST和符号依赖分析的检索增强生成（RAG）系统。
*   **执行环境:** 一个安全的、隔离的沙箱环境，用于编译代码、运行测试、Linter和Formatter。
*   **LLM接口:** 一个支持动态路由到多个模型（本地Ollama、远程API）的抽象层。

---

### **5. 绝对规则与质量标准**

*   **禁止占位符:** 所有输出必须是完整、可直接使用的最终版本，严禁使用“...”、“同上”等省略性内容。
*   **完整文件输出:** 即使是微小的修改，也必须输出修改后的整个文件内容，而非代码片段。
*   **一致性维护:** 修改代码时，必须自动检查并同步更新所有相关部分（如测试、文档、变量名）。
*   **禁止绕过质量门禁:** 系统在任何情况下都不能使用`--no-verify`等参数绕过Git钩子，也不能禁用测试来代替修复。
*   **提交要求:** 每一次代码提交都必须确保代码可编译、通过所有测试、并符合格式化标准。

---

### **6. 未来路线图**

*   **高级交互式调试:** 赋予AI分析运行时日志、设置断点（模拟）、并进行交互式调试的能力。
*   **自动化文档生成:** 在代码开发完成后，自动生成或更新API文档、代码注释和项目的README文件。
*   **基础设施即代码 (IaC) 生成:** 能够根据项目特性，自动生成`Dockerfile`、`docker-compose.yml`或CI/CD流水线配置文件（如GitHub Actions）。